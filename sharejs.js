minispade.register('sharejs', "(function() {(function() {\n  var BCSocket, Connection, Doc, MicroEvent, SockJS, append, bootstrapTransform, checkValidComponent, checkValidOp, exports, hasBCSocket, hasSockJS, invertComponent, nextTick, strInject, text, transformComponent, transformPosition, types, useSockJS,\n    __slice = Array.prototype.slice,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  window.sharejs = exports = {\n    'version': '0.5.0-pre'\n  };\n\n  if (typeof WEB === 'undefined') window.WEB = true;\n\n  nextTick = typeof WEB !== \"undefined\" && WEB !== null ? function(fn) {\n    return setTimeout(fn, 0);\n  } : process['nextTick'];\n\n  MicroEvent = (function() {\n\n    function MicroEvent() {}\n\n    MicroEvent.prototype.on = function(event, fct) {\n      var _base;\n      this._events || (this._events = {});\n      (_base = this._events)[event] || (_base[event] = []);\n      this._events[event].push(fct);\n      return this;\n    };\n\n    MicroEvent.prototype.removeListener = function(event, fct) {\n      var i, listeners, _base,\n        _this = this;\n      this._events || (this._events = {});\n      listeners = ((_base = this._events)[event] || (_base[event] = []));\n      i = 0;\n      while (i < listeners.length) {\n        if (listeners[i] === fct) listeners[i] = void 0;\n        i++;\n      }\n      nextTick(function() {\n        var x;\n        return _this._events[event] = (function() {\n          var _i, _len, _ref, _results;\n          _ref = this._events[event];\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            x = _ref[_i];\n            if (x) _results.push(x);\n          }\n          return _results;\n        }).call(_this);\n      });\n      return this;\n    };\n\n    MicroEvent.prototype.emit = function() {\n      var args, event, fn, _i, _len, _ref, _ref2;\n      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if (!((_ref = this._events) != null ? _ref[event] : void 0)) return this;\n      _ref2 = this._events[event];\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        fn = _ref2[_i];\n        if (fn) fn.apply(this, args);\n      }\n      return this;\n    };\n\n    return MicroEvent;\n\n  })();\n\n  MicroEvent.mixin = function(obj) {\n    var proto;\n    proto = obj.prototype || obj;\n    proto.on = MicroEvent.prototype.on;\n    proto.removeListener = MicroEvent.prototype.removeListener;\n    proto.emit = MicroEvent.prototype.emit;\n    return obj;\n  };\n\n  if (typeof WEB === \"undefined\" || WEB === null) module.exports = MicroEvent;\n\n  exports['_bt'] = bootstrapTransform = function(type, transformComponent, checkValidOp, append) {\n    var transformComponentX, transformX;\n    transformComponentX = function(left, right, destLeft, destRight) {\n      transformComponent(destLeft, left, right, 'left');\n      return transformComponent(destRight, right, left, 'right');\n    };\n    type.transformX = type['transformX'] = transformX = function(leftOp, rightOp) {\n      var k, l, l_, newLeftOp, newRightOp, nextC, r, r_, rightComponent, _i, _j, _k, _l, _len, _len2, _len3, _len4, _ref, _ref2;\n      checkValidOp(leftOp);\n      checkValidOp(rightOp);\n      newRightOp = [];\n      for (_i = 0, _len = rightOp.length; _i < _len; _i++) {\n        rightComponent = rightOp[_i];\n        newLeftOp = [];\n        k = 0;\n        while (k < leftOp.length) {\n          nextC = [];\n          transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n          k++;\n          if (nextC.length === 1) {\n            rightComponent = nextC[0];\n          } else if (nextC.length === 0) {\n            _ref = leftOp.slice(k);\n            for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              l = _ref[_j];\n              append(newLeftOp, l);\n            }\n            rightComponent = null;\n            break;\n          } else {\n            _ref2 = transformX(leftOp.slice(k), nextC), l_ = _ref2[0], r_ = _ref2[1];\n            for (_k = 0, _len3 = l_.length; _k < _len3; _k++) {\n              l = l_[_k];\n              append(newLeftOp, l);\n            }\n            for (_l = 0, _len4 = r_.length; _l < _len4; _l++) {\n              r = r_[_l];\n              append(newRightOp, r);\n            }\n            rightComponent = null;\n            break;\n          }\n        }\n        if (rightComponent != null) append(newRightOp, rightComponent);\n        leftOp = newLeftOp;\n      }\n      return [leftOp, newRightOp];\n    };\n    return type.transform = type['transform'] = function(op, otherOp, type) {\n      var left, right, _, _ref, _ref2;\n      if (!(type === 'left' || type === 'right')) {\n        throw new Error(\"type must be 'left' or 'right'\");\n      }\n      if (otherOp.length === 0) return op;\n      if (op.length === 1 && otherOp.length === 1) {\n        return transformComponent([], op[0], otherOp[0], type);\n      }\n      if (type === 'left') {\n        _ref = transformX(op, otherOp), left = _ref[0], _ = _ref[1];\n        return left;\n      } else {\n        _ref2 = transformX(otherOp, op), _ = _ref2[0], right = _ref2[1];\n        return right;\n      }\n    };\n  };\n\n  if (typeof WEB === 'undefined') exports.bootstrapTransform = bootstrapTransform;\n\n  text = {};\n\n  text.name = 'text';\n\n  text.create = function() {\n    return '';\n  };\n\n  strInject = function(s1, pos, s2) {\n    return s1.slice(0, pos) + s2 + s1.slice(pos);\n  };\n\n  checkValidComponent = function(c) {\n    var d_type, i_type;\n    if (typeof c.p !== 'number') {\n      throw new Error('component missing position field');\n    }\n    i_type = typeof c.i;\n    d_type = typeof c.d;\n    if (!((i_type === 'string') ^ (d_type === 'string'))) {\n      throw new Error('component needs an i or d field');\n    }\n    if (!(c.p >= 0)) throw new Error('position cannot be negative');\n  };\n\n  checkValidOp = function(op) {\n    var c, _i, _len;\n    for (_i = 0, _len = op.length; _i < _len; _i++) {\n      c = op[_i];\n      checkValidComponent(c);\n    }\n    return true;\n  };\n\n  text.apply = function(snapshot, op) {\n    var component, deleted, _i, _len;\n    checkValidOp(op);\n    for (_i = 0, _len = op.length; _i < _len; _i++) {\n      component = op[_i];\n      if (component.i != null) {\n        snapshot = strInject(snapshot, component.p, component.i);\n      } else {\n        deleted = snapshot.slice(component.p, (component.p + component.d.length));\n        if (component.d !== deleted) {\n          throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n        }\n        snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n      }\n    }\n    return snapshot;\n  };\n\n  text._append = append = function(newOp, c) {\n    var last, _ref, _ref2;\n    if (c.i === '' || c.d === '') return;\n    if (newOp.length === 0) {\n      return newOp.push(c);\n    } else {\n      last = newOp[newOp.length - 1];\n      if ((last.i != null) && (c.i != null) && (last.p <= (_ref = c.p) && _ref <= (last.p + last.i.length))) {\n        return newOp[newOp.length - 1] = {\n          i: strInject(last.i, c.p - last.p, c.i),\n          p: last.p\n        };\n      } else if ((last.d != null) && (c.d != null) && (c.p <= (_ref2 = last.p) && _ref2 <= (c.p + c.d.length))) {\n        return newOp[newOp.length - 1] = {\n          d: strInject(c.d, last.p - c.p, last.d),\n          p: c.p\n        };\n      } else {\n        return newOp.push(c);\n      }\n    }\n  };\n\n  text.compose = function(op1, op2) {\n    var c, newOp, _i, _len;\n    checkValidOp(op1);\n    checkValidOp(op2);\n    newOp = op1.slice();\n    for (_i = 0, _len = op2.length; _i < _len; _i++) {\n      c = op2[_i];\n      append(newOp, c);\n    }\n    return newOp;\n  };\n\n  text.compress = function(op) {\n    return text.compose([], op);\n  };\n\n  text.normalize = function(op) {\n    var c, newOp, _i, _len;\n    newOp = [];\n    if ((op.i != null) || (op.p != null)) op = [op];\n    for (_i = 0, _len = op.length; _i < _len; _i++) {\n      c = op[_i];\n      if (c.p == null) c.p = 0;\n      append(newOp, c);\n    }\n    return newOp;\n  };\n\n  transformPosition = function(pos, c, insertAfter) {\n    if (c.i != null) {\n      if (c.p < pos || (c.p === pos && insertAfter)) {\n        return pos + c.i.length;\n      } else {\n        return pos;\n      }\n    } else {\n      if (pos <= c.p) {\n        return pos;\n      } else if (pos <= c.p + c.d.length) {\n        return c.p;\n      } else {\n        return pos - c.d.length;\n      }\n    }\n  };\n\n  text.transformCursor = function(position, op, insertAfter) {\n    var c, _i, _len;\n    for (_i = 0, _len = op.length; _i < _len; _i++) {\n      c = op[_i];\n      position = transformPosition(position, c, insertAfter);\n    }\n    return position;\n  };\n\n  text._tc = transformComponent = function(dest, c, otherC, type) {\n    var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n    checkValidOp([c]);\n    checkValidOp([otherC]);\n    if (c.i != null) {\n      append(dest, {\n        i: c.i,\n        p: transformPosition(c.p, otherC, type === 'right')\n      });\n    } else {\n      if (otherC.i != null) {\n        s = c.d;\n        if (c.p < otherC.p) {\n          append(dest, {\n            d: s.slice(0, (otherC.p - c.p)),\n            p: c.p\n          });\n          s = s.slice(otherC.p - c.p);\n        }\n        if (s !== '') {\n          append(dest, {\n            d: s,\n            p: c.p + otherC.i.length\n          });\n        }\n      } else {\n        if (c.p >= otherC.p + otherC.d.length) {\n          append(dest, {\n            d: c.d,\n            p: c.p - otherC.d.length\n          });\n        } else if (c.p + c.d.length <= otherC.p) {\n          append(dest, c);\n        } else {\n          newC = {\n            d: '',\n            p: c.p\n          };\n          if (c.p < otherC.p) newC.d = c.d.slice(0, (otherC.p - c.p));\n          if (c.p + c.d.length > otherC.p + otherC.d.length) {\n            newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n          }\n          intersectStart = Math.max(c.p, otherC.p);\n          intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n          cIntersect = c.d.slice(intersectStart - c.p, (intersectEnd - c.p));\n          otherIntersect = otherC.d.slice(intersectStart - otherC.p, (intersectEnd - otherC.p));\n          if (cIntersect !== otherIntersect) {\n            throw new Error('Delete ops delete different text in the same region of the document');\n          }\n          if (newC.d !== '') {\n            newC.p = transformPosition(newC.p, otherC);\n            append(dest, newC);\n          }\n        }\n      }\n    }\n    return dest;\n  };\n\n  invertComponent = function(c) {\n    if (c.i != null) {\n      return {\n        d: c.i,\n        p: c.p\n      };\n    } else {\n      return {\n        i: c.d,\n        p: c.p\n      };\n    }\n  };\n\n  text.invert = function(op) {\n    var c, _i, _len, _ref, _results;\n    _ref = op.slice().reverse();\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      c = _ref[_i];\n      _results.push(invertComponent(c));\n    }\n    return _results;\n  };\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    exports.types || (exports.types = {});\n    bootstrapTransform(text, transformComponent, checkValidOp, append);\n    exports.types.text = text;\n  } else {\n    module.exports = text;\nminispade.require('./helpers').bootstrapTransform(text, transformComponent, checkValidOp, append);\n  }\n\n  if (typeof WEB === 'undefined') text = require('./text');\n\n  text.api = {\n    provides: {\n      text: true\n    },\n    getLength: function() {\n      return this.snapshot.length;\n    },\n    getText: function() {\n      return this.snapshot;\n    },\n    insert: function(pos, text, callback) {\n      var op;\n      op = [\n        {\n          p: pos,\n          i: text\n        }\n      ];\n      this.submitOp(op, callback);\n      return op;\n    },\n    del: function(pos, length, callback) {\n      var op;\n      op = [\n        {\n          p: pos,\n          d: this.snapshot.slice(pos, (pos + length))\n        }\n      ];\n      this.submitOp(op, callback);\n      return op;\n    },\n    _register: function() {\n      return this.on('remoteop', function(op) {\n        var component, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = op.length; _i < _len; _i++) {\n          component = op[_i];\n          if (component.i !== void 0) {\n            _results.push(this.emit('insert', component.p, component.i));\n          } else {\n            _results.push(this.emit('delete', component.p, component.d));\n          }\n        }\n        return _results;\n      });\n    }\n  };\n\n  if (typeof WEB === \"undefined\" || WEB === null) types = require('../types');\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    exports.extendDoc = function(name, fn) {\n      return Doc.prototype[name] = fn;\n    };\n  }\n\n  Doc = (function() {\n\n    function Doc(connection, name, openData) {\n      this.connection = connection;\n      this.name = name;\n      this.shout = __bind(this.shout, this);\n      this.flush = __bind(this.flush, this);\n      openData || (openData = {});\n      this.version = openData.v;\n      this.snapshot = openData.snaphot;\n      if (openData.type) this._setType(openData.type);\n      this.state = 'closed';\n      this.autoOpen = false;\n      this._create = openData.create;\n      this.inflightOp = null;\n      this.inflightCallbacks = [];\n      this.inflightSubmittedIds = [];\n      this.pendingOp = null;\n      this.pendingCallbacks = [];\n      this.serverOps = {};\n    }\n\n    Doc.prototype._xf = function(client, server) {\n      var client_, server_;\n      if (this.type.transformX) {\n        return this.type.transformX(client, server);\n      } else {\n        client_ = this.type.transform(client, server, 'left');\n        server_ = this.type.transform(server, client, 'right');\n        return [client_, server_];\n      }\n    };\n\n    Doc.prototype._otApply = function(docOp, isRemote) {\n      var oldSnapshot;\n      oldSnapshot = this.snapshot;\n      this.snapshot = this.type.apply(this.snapshot, docOp);\n      this.emit('change', docOp, oldSnapshot);\n      if (isRemote) return this.emit('remoteop', docOp, oldSnapshot);\n    };\n\n    Doc.prototype._connectionStateChanged = function(state, data) {\n      switch (state) {\n        case 'disconnected':\n          this.state = 'closed';\n          if (this.inflightOp) this.inflightSubmittedIds.push(this.connection.id);\n          this.emit('closed');\n          break;\n        case 'ok':\n          if (this.autoOpen) this.open();\n          break;\n        case 'stopped':\n          if (typeof this._openCallback === \"function\") this._openCallback(data);\n      }\n      return this.emit(state, data);\n    };\n\n    Doc.prototype._setType = function(type) {\n      var k, v, _ref;\n      if (typeof type === 'string') type = types[type];\n      if (!(type && type.compose)) {\n        throw new Error('Support for types without compose() is not implemented');\n      }\n      this.type = type;\n      if (type.api) {\n        _ref = type.api;\n        for (k in _ref) {\n          v = _ref[k];\n          this[k] = v;\n        }\n        return typeof this._register === \"function\" ? this._register() : void 0;\n      } else {\n        return this.provides = {};\n      }\n    };\n\n    Doc.prototype._onMessage = function(msg) {\n      var callback, docOp, error, oldInflightOp, op, path, response, undo, value, _i, _j, _len, _len2, _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n      if (msg.open === true) {\n        this.state = 'open';\n        this._create = false;\n        if (this.created == null) this.created = !!msg.create;\n        if (msg.type) this._setType(msg.type);\n        if (msg.create) {\n          this.created = true;\n          this.snapshot = this.type.create();\n        } else {\n          if (this.created !== true) this.created = false;\n          if (msg.snapshot !== void 0) this.snapshot = msg.snapshot;\n        }\n        if (msg.v != null) this.version = msg.v;\n        if (this.inflightOp) {\n          response = {\n            doc: this.name,\n            op: this.inflightOp,\n            v: this.version\n          };\n          if (this.inflightSubmittedIds.length) {\n            response.dupIfSource = this.inflightSubmittedIds;\n          }\n          this.connection.send(response);\n        } else {\n          this.flush();\n        }\n        this.emit('open');\n        return typeof this._openCallback === \"function\" ? this._openCallback(null) : void 0;\n      } else if (msg.open === false) {\n        if (msg.error) {\n          if (typeof console !== \"undefined\" && console !== null) {\n            console.error(\"Could not open document: \" + msg.error);\n          }\n          this.emit('error', msg.error);\n          if (typeof this._openCallback === \"function\") {\n            this._openCallback(msg.error);\n          }\n        }\n        this.state = 'closed';\n        this.emit('closed');\n        if (typeof this._closeCallback === \"function\") this._closeCallback();\n        return this._closeCallback = null;\n      } else if (msg.op === null && error === 'Op already submitted') {} else if ((msg.op === void 0 && msg.v !== void 0) || (msg.op && (_ref = msg.meta.source, __indexOf.call(this.inflightSubmittedIds, _ref) >= 0))) {\n        oldInflightOp = this.inflightOp;\n        this.inflightOp = null;\n        this.inflightSubmittedIds.length = 0;\n        error = msg.error;\n        if (error) {\n          if (this.type.invert) {\n            undo = this.type.invert(oldInflightOp);\n            if (this.pendingOp) {\n              _ref2 = this._xf(this.pendingOp, undo), this.pendingOp = _ref2[0], undo = _ref2[1];\n            }\n            this._otApply(undo, true);\n          } else {\n            this.emit('error', \"Op apply failed (\" + error + \") and the op could not be reverted\");\n          }\n          _ref3 = this.inflightCallbacks;\n          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n            callback = _ref3[_i];\n            callback(error);\n          }\n        } else {\n          if (msg.v !== this.version) {\n            throw new Error('Invalid version from server');\n          }\n          this.serverOps[this.version] = oldInflightOp;\n          this.version++;\n          _ref4 = this.inflightCallbacks;\n          for (_j = 0, _len2 = _ref4.length; _j < _len2; _j++) {\n            callback = _ref4[_j];\n            callback(null, oldInflightOp);\n          }\n        }\n        return this.flush();\n      } else if (msg.op) {\n        if (msg.v < this.version) return;\n        if (msg.doc !== this.name) {\n          return this.emit('error', \"Expected docName '\" + this.name + \"' but got \" + msg.doc);\n        }\n        if (msg.v !== this.version) {\n          return this.emit('error', \"Expected version \" + this.version + \" but got \" + msg.v);\n        }\n        op = msg.op;\n        this.serverOps[this.version] = op;\n        docOp = op;\n        if (this.inflightOp !== null) {\n          _ref5 = this._xf(this.inflightOp, docOp), this.inflightOp = _ref5[0], docOp = _ref5[1];\n        }\n        if (this.pendingOp !== null) {\n          _ref6 = this._xf(this.pendingOp, docOp), this.pendingOp = _ref6[0], docOp = _ref6[1];\n        }\n        this.version++;\n        return this._otApply(docOp, true);\n      } else if (msg.meta) {\n        _ref7 = msg.meta, path = _ref7.path, value = _ref7.value;\n        switch (path != null ? path[0] : void 0) {\n          case 'shout':\n            return this.emit('shout', value);\n          default:\n            return typeof console !== \"undefined\" && console !== null ? console.warn('Unhandled meta op:', msg) : void 0;\n        }\n      } else {\n        return typeof console !== \"undefined\" && console !== null ? console.warn('Unhandled document message:', msg) : void 0;\n      }\n    };\n\n    Doc.prototype.flush = function() {\n      if (!(this.connection.state === 'ok' && this.inflightOp === null && this.pendingOp !== null)) {\n        return;\n      }\n      this.inflightOp = this.pendingOp;\n      this.inflightCallbacks = this.pendingCallbacks;\n      this.pendingOp = null;\n      this.pendingCallbacks = [];\n      return this.connection.send({\n        doc: this.name,\n        op: this.inflightOp,\n        v: this.version\n      });\n    };\n\n    Doc.prototype.submitOp = function(op, callback) {\n      if (this.type.normalize != null) op = this.type.normalize(op);\n      this.snapshot = this.type.apply(this.snapshot, op);\n      if (this.pendingOp !== null) {\n        this.pendingOp = this.type.compose(this.pendingOp, op);\n      } else {\n        this.pendingOp = op;\n      }\n      if (callback) this.pendingCallbacks.push(callback);\n      this.emit('change', op);\n      return setTimeout(this.flush, 0);\n    };\n\n    Doc.prototype.shout = function(msg) {\n      return this.connection.send({\n        doc: this.name,\n        meta: {\n          path: ['shout'],\n          value: msg\n        }\n      });\n    };\n\n    Doc.prototype.open = function(callback) {\n      var message,\n        _this = this;\n      this.autoOpen = true;\n      if (this.state !== 'closed') return;\n      message = {\n        doc: this.name,\n        open: true\n      };\n      if (this.snapshot === void 0) message.snapshot = null;\n      if (this.type) message.type = this.type.name;\n      if (this.version != null) message.v = this.version;\n      if (this._create) message.create = true;\n      this.connection.send(message);\n      this.state = 'opening';\n      return this._openCallback = function(error) {\n        _this._openCallback = null;\n        return typeof callback === \"function\" ? callback(error) : void 0;\n      };\n    };\n\n    Doc.prototype.close = function(callback) {\n      this.autoOpen = false;\n      if (this.state === 'closed') {\n        return typeof callback === \"function\" ? callback() : void 0;\n      }\n      this.connection.send({\n        doc: this.name,\n        open: false\n      });\n      this.state = 'closed';\n      this.emit('closing');\n      return this._closeCallback = callback;\n    };\n\n    return Doc;\n\n  })();\n\n  if (typeof WEB === \"undefined\" || WEB === null) {\n    MicroEvent = require('./microevent');\n  }\n\n  MicroEvent.mixin(Doc);\n\n  exports.Doc = Doc;\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    types = exports.types;\n    BCSocket = window.BCSocket, SockJS = window.SockJS;\n  } else {\n    types = require('../types');\n    BCSocket = require('browserchannel').BCSocket;\n    Doc = require('./doc').Doc;\n  }\n\n  Connection = (function() {\n\n    function Connection(host) {\n      var _this = this;\n      this.docs = {};\n      this.state = 'connecting';\n      this.socket = typeof useSockJS !== \"undefined\" && useSockJS !== null ? new SockJS(host) : new BCSocket(host, {\n        reconnect: true\n      });\n      this.socket.onmessage = function(msg) {\n        var docName;\n        if (typeof useSockJS !== \"undefined\" && useSockJS !== null) {\n          msg = JSON.parse(msg.data);\n        }\n        if (msg.auth === null) {\n          _this.lastError = msg.error;\n          _this.disconnect();\n          return _this.emit('connect failed', msg.error);\n        } else if (msg.auth) {\n          _this.id = msg.auth;\n          _this.setState('ok');\n          return;\n        }\n        docName = msg.doc;\n        if (docName !== void 0) {\n          _this.lastReceivedDoc = docName;\n        } else {\n          msg.doc = docName = _this.lastReceivedDoc;\n        }\n        if (_this.docs[docName]) {\n          return _this.docs[docName]._onMessage(msg);\n        } else {\n          return typeof console !== \"undefined\" && console !== null ? console.error('Unhandled message', msg) : void 0;\n        }\n      };\n      this.connected = false;\n      this.socket.onclose = function(reason) {\n        _this.setState('disconnected', reason);\n        if (reason === 'Closed' || reason === 'Stopped by server') {\n          return _this.setState('stopped', _this.lastError || reason);\n        }\n      };\n      this.socket.onerror = function(e) {\n        return _this.emit('error', e);\n      };\n      this.socket.onopen = function() {\n        _this.lastError = _this.lastReceivedDoc = _this.lastSentDoc = null;\n        return _this.setState('handshaking');\n      };\n      this.socket.onconnecting = function() {\n        return _this.setState('connecting');\n      };\n    }\n\n    Connection.prototype.setState = function(state, data) {\n      var doc, docName, _ref, _results;\n      if (this.state === state) return;\n      this.state = state;\n      if (state === 'disconnected') delete this.id;\n      this.emit(state, data);\n      _ref = this.docs;\n      _results = [];\n      for (docName in _ref) {\n        doc = _ref[docName];\n        _results.push(doc._connectionStateChanged(state, data));\n      }\n      return _results;\n    };\n\n    Connection.prototype.send = function(data) {\n      var docName;\n      docName = data.doc;\n      if (docName === this.lastSentDoc) {\n        delete data.doc;\n      } else {\n        this.lastSentDoc = docName;\n      }\n      if (typeof useSockJS !== \"undefined\" && useSockJS !== null) {\n        data = JSON.stringify(data);\n      }\n      return this.socket.send(data);\n    };\n\n    Connection.prototype.disconnect = function() {\n      return this.socket.close();\n    };\n\n    Connection.prototype.makeDoc = function(name, data, callback) {\n      var doc,\n        _this = this;\n      if (this.docs[name]) throw new Error(\"Doc \" + name + \" already open\");\n      doc = new Doc(this, name, data);\n      this.docs[name] = doc;\n      return doc.open(function(error) {\n        if (error) delete _this.docs[name];\n        return callback(error, (!error ? doc : void 0));\n      });\n    };\n\n    Connection.prototype.openExisting = function(docName, callback) {\n      var doc;\n      if (this.state === 'stopped') return callback('connection closed');\n      if (this.docs[docName]) return callback(null, this.docs[docName]);\n      return doc = this.makeDoc(docName, {}, callback);\n    };\n\n    Connection.prototype.open = function(docName, type, callback) {\n      var doc;\n      if (this.state === 'stopped') return callback('connection closed');\n      if (this.state === 'connecting') {\n        this.on('handshaking', function() {\n          return this.open(docName, type, callback);\n        });\n        return;\n      }\n      if (typeof type === 'function') {\n        callback = type;\n        type = 'text';\n      }\n      callback || (callback = function() {});\n      if (typeof type === 'string') type = types[type];\n      if (!type) throw new Error(\"OT code for document type missing\");\n      if (docName == null) {\n        throw new Error('Server-generated random doc names are not currently supported');\n      }\n      if (this.docs[docName]) {\n        doc = this.docs[docName];\n        if (doc.type === type) {\n          callback(null, doc);\n        } else {\n          callback('Type mismatch', doc);\n        }\n        return;\n      }\n      return this.makeDoc(docName, {\n        create: true,\n        type: type.name\n      }, callback);\n    };\n\n    return Connection;\n\n  })();\n\n  if (typeof WEB === \"undefined\" || WEB === null) {\n    MicroEvent = require('./microevent');\n  }\n\n  MicroEvent.mixin(Connection);\n\n  exports.Connection = Connection;\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    hasBCSocket = window.BCSocket !== void 0;\n    hasSockJS = window.SockJS !== void 0;\n    if (!(hasBCSocket || hasSockJS)) {\n      throw new Error('Must load socks or browserchannel before this library');\n    }\n    useSockJS = hasSockJS && !hasBCSocket;\n  } else {\n    Connection = require('./connection').Connection;\n  }\n\n  exports.open = (function() {\n    var connections, getConnection, maybeClose;\n    connections = {};\n    getConnection = function(origin) {\n      var c, del, location, path;\n      if (typeof WEB !== \"undefined\" && WEB !== null) {\n        location = window.location;\n        path = useSockJS ? 'sockjs' : 'channel';\n        if (origin == null) {\n          origin = \"\" + location.protocol + \"//\" + location.host + \"/\" + path;\n        }\n      }\n      if (!connections[origin]) {\n        c = new Connection(origin);\n        del = function() {\n          return delete connections[origin];\n        };\n        c.on('disconnecting', del);\n        c.on('connect failed', del);\n        connections[origin] = c;\n      }\n      return connections[origin];\n    };\n    maybeClose = function(c) {\n      var doc, name, numDocs, _ref;\n      numDocs = 0;\n      _ref = c.docs;\n      for (name in _ref) {\n        doc = _ref[name];\n        if (doc.state !== 'closed' || doc.autoOpen) numDocs++;\n      }\n      if (numDocs === 0) return c.disconnect();\n    };\n    return function(docName, type, origin, callback) {\n      var c;\n      if (typeof origin === 'function') {\n        callback = origin;\n        origin = null;\n      }\n      c = getConnection(origin);\n      c.numDocs++;\n      c.open(docName, type, function(error, doc) {\n        if (error) {\n          callback(error);\n          return maybeClose(c);\n        } else {\n          doc.on('closed', function() {\n            return maybeClose(c);\n          });\n          return callback(null, doc);\n        }\n      });\n      c.on('connect failed');\n      return c;\n    };\n  })();\n\n  if (typeof WEB === \"undefined\" || WEB === null) {\n    exports.Doc = require('./doc').Doc;\n    exports.Connection = require('./connection').Connection;\n  }\n\n}).call(this);\n\n})();\n//@ sourceURL=sharejs");